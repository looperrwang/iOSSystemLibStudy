/*
See LICENSE folder for this sampleâ€™s licensing information.

Abstract:
Metal shaders used to create G-buffer
*/
#include <metal_stdlib>

using namespace metal;

// Include header shared between this Metal shader code and C code executing Metal API commands
#import "AAPLShaderTypes.h"

// Include header shared between all Metal shader code files
#import "AAPLShaderCommon.h"

// Vertex shader outputs and per-fragment inputs.  Includes clip-space position and vertex outputs
// interpolated by rasterizer and fed to each fragment generated by clip-space primitives.
typedef struct
{
    float4 position [[position]];
    float2 tex_coord;
    float3 shadow_coord;
    float3 eye_position;
    half3 tangent;
    half3 bitangent;
    half3 normal;
} ColorInOut;

vertex ColorInOut gbuffer_vertex(Vertex                 in        [[ stage_in ]],
                                 constant AAPLUniforms &uniforms  [[ buffer(AAPLBufferIndexUniforms) ]])
{
    ColorInOut out;

    float4 model_position = float4(in.position, 1.0);
    // Make position a float4 to perform 4x4 matrix math on it
    float4 eye_position = uniforms.temple_modelview_matrix * model_position;
    out.position = uniforms.projection_matrix * eye_position;
    out.tex_coord = in.tex_coord;

#if USE_EYE_DEPTH || (APPLY_DIRECTIONAL_SPECULAR && !DEFER_ALL_LIGHTING)
    out.eye_position = eye_position.xyz;
#endif

    // Rotate our tangents, bitangents, and normals by the normal matrix
    half3x3 normalMatrix = half3x3(uniforms.temple_normal_matrix);

    out.shadow_coord = (uniforms.shadow_mvp_xform_matrix * model_position ).xyz;

    // Calculate tangent, bitangent and normal in eye's space
    out.tangent = normalize(normalMatrix * in.tangent);
    out.bitangent = -normalize(normalMatrix * in.bitangent);
    out.normal = normalize(normalMatrix * in.normal);

    return out;
}

fragment GBufferData gbuffer_fragment(ColorInOut             in           [[ stage_in ]],
                                      constant AAPLUniforms &uniforms     [[ buffer(AAPLBufferIndexUniforms) ]],
                                      texture2d<half>        baseColorMap [[ texture(AAPLTextureIndexBaseColor) ]],
                                      texture2d<half>        normalMap    [[ texture(AAPLTextureIndexNormal) ]],
                                      texture2d<half>        specularMap  [[ texture(AAPLTextureIndexSpecular) ]],
                                      depth2d<float>         shadowMap    [[ texture(AAPLTextureIndexShadow) ]])
{
    constexpr sampler linearSampler(mip_filter::linear,
                                    mag_filter::linear,
                                    min_filter::linear);

    half4 base_color_sample = baseColorMap.sample(linearSampler, in.tex_coord.xy);
    half4 normal_sample = normalMap.sample(linearSampler, in.tex_coord.xy);
    half specular_contrib = specularMap.sample(linearSampler, in.tex_coord.xy).r;

    // Fill in on-chip geometry buffer data
    GBufferData gBuffer;

    // Calculate normal in eye space
    half3 tangent_normal = normalize((normal_sample.xyz * 2.0) - 1.0);

    half3 eye_normal = (tangent_normal.x * in.tangent +
                        tangent_normal.y * in.bitangent +
                        tangent_normal.z * in.normal);

    eye_normal = normalize(eye_normal);

    constexpr sampler shadowSampler(coord::normalized,
                                    filter::linear,
                                    mip_filter::none,
                                    address::clamp_to_edge,
                                    compare_func::less);

    // Compare the depth value in the shadow map to the depth value of the fragment in the sun's.
    // frame of reference.  If the sample is occluded, it will be zero.
    float shadow_sample = shadowMap.sample_compare(shadowSampler, in.shadow_coord.xy, in.shadow_coord.z);

#if !DEFER_ALL_LIGHTING

    // Lighten shadow to account for ambient light
    half shadow_contribution = shadow_sample + 0.1h;

    // Clamp shadow values to 1;
    shadow_contribution = min(1.0h, shadow_contribution);

    half directional_light_intensity = dot(eye_normal.xyz, half3(uniforms.sun_eye_direction.xyz));

    directional_light_intensity = max(directional_light_intensity, 0.0h);

    // Add shadow contribution
    directional_light_intensity *= shadow_contribution;

    half4 direction_light_color = half4(uniforms.sun_color);

    gBuffer.lighting = (base_color_sample *
                        direction_light_color *
                        directional_light_intensity);

#if APPLY_DIRECTIONAL_SPECULAR

    float4 eye_light_direction = uniforms.sun_eye_direction;

    float3 eye_space_fragment_pos = normalize(in.eye_position) * in.position.z;

    half3 halfway_vector = half3(normalize(eye_space_fragment_pos - eye_light_direction.xyz));

    half specular_intensity = half(uniforms.sun_specular_intensity);

    half specular_shininess = specular_contrib * half(uniforms.shininess_factor);

    half specular_factor = powr( max( dot(eye_normal,halfway_vector), 0.h), specular_intensity);

    half4 specular_contribution = (specular_factor *
                                   base_color_sample *
                                   specular_shininess *
                                   direction_light_color);

   gBuffer.lighting += specular_contribution;

#endif // END APPLY_DIRECTIONAL_SPECULAR

#endif // END not DEFER_ALL_LIGHTING

    // Store shadow with albedo in unused fourth channel
    gBuffer.albedo_specular = half4(base_color_sample.xyz, specular_contrib);

    // Store the specular contribution with the normal in unused fourth channel.
    gBuffer.normal_shadow = half4(eye_normal.xyz, shadow_sample);

#if USE_EYE_DEPTH
    gBuffer.depth = in.eye_position.z;
#else
    gBuffer.depth = in.position.z;
#endif

    return gBuffer;
}

